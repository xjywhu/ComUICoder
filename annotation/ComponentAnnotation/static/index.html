<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šé¡µé¢å›¾ç‰‡æ ‡æ³¨å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .main-content {
            display: flex;
            gap: 20px;
            padding: 20px;
            min-height: calc(100vh - 200px);
        }

        .canvas-area {
            flex: 3;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .sidebar {
            flex: 1;
            min-width: 280px;
            max-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-wrapper {
            position: relative;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: auto;
            background: #fafafa;
            max-height: calc(100vh - 300px);
            min-height: 400px;
        }

        #canvas {
            display: block;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
        }

        .info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }

        .section {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            flex-shrink: 0;
        }

        .section h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-danger {
            background: #f56565;
            color: white;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .rectangle-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .rectangle-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .rectangle-item .coords {
            color: #666;
        }

        .rectangle-item .delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .status {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
            display: none;
            white-space: pre-line;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.show {
            display: block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“ å¤šé¡µé¢å›¾ç‰‡æ ‡æ³¨å·¥å…·</h1>
            <p>æ‹–æ‹½é¼ æ ‡ç»˜åˆ¶çŸ©å½¢æ¡†ï¼Œè‡ªåŠ¨ä¿å­˜æ ‡æ³¨åŒºåŸŸå’Œåæ ‡ä¿¡æ¯</p>
        </div>

        <div class="main-content">
            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <canvas id="canvas"></canvas>
                </div>
                <div class="info-panel">
                    <div><strong>ğŸ“ å½“å‰æ–‡ä»¶å¤¹:</strong> <span id="folderInfo">-</span></div>
                    <div><strong>ğŸ“„ å½“å‰é¡µé¢:</strong> <span id="pageInfo">-</span></div>
                    <div><strong>ğŸ”² å·²æ ‡æ³¨åŒºåŸŸ:</strong> <span id="rectCount">0</span></div>
                    <div style="margin-top: 10px; color: #999; font-size: 12px;">
                        ğŸ’¡ æç¤º:<br>
                        â€¢ æ‹–æ‹½ç»˜åˆ¶æ–°çŸ©å½¢æ¡†<br>
                        â€¢ ç‚¹å‡»çŸ©å½¢å¯ç§»åŠ¨ä½ç½®<br>
                        â€¢ æ‹–æ‹½è§’è½/è¾¹ç¼˜è°ƒæ•´å¤§å°<br>
                        â€¢ Shift+ç‚¹å‡»åˆ é™¤çŸ©å½¢
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="section">
                    <h3>ğŸ—‚ï¸ å¯¼èˆªæ§åˆ¶</h3>
                    <div class="btn-row">
                        <button class="btn btn-secondary" onclick="prevFolder()">â¬…ï¸ ä¸Šä¸ªæ–‡ä»¶å¤¹</button>
                        <button class="btn btn-secondary" onclick="nextFolder()">ä¸‹ä¸ªæ–‡ä»¶å¤¹ â¡ï¸</button>
                    </div>
                    <div class="btn-row">
                        <button class="btn btn-secondary" onclick="prevPage()">â¬…ï¸ ä¸Šä¸€é¡µ</button>
                        <button class="btn btn-secondary" onclick="nextPage()">ä¸‹ä¸€é¡µ â¡ï¸</button>
                    </div>
                </div>

                <div class="section">
                    <h3>âœï¸ æ ‡æ³¨åŒºåŸŸ</h3>
                    <div class="rectangle-list" id="rectangleList"></div>
                    <button class="btn btn-danger" onclick="clearRectangles()" style="margin-top: 10px;">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰</button>
                </div>

                <div class="section">
                    <h3>ğŸ’¾ ä¿å­˜</h3>
                    <button class="btn btn-primary" onclick="saveAnnotations()" id="saveBtn">ğŸ’¾ ä¿å­˜æ‰€æœ‰åŒºåŸŸ</button>
                    <div class="status" id="status"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // APIé…ç½®
        const API_BASE = 'http://localhost:7881/api';

        // åº”ç”¨çŠ¶æ€
        const state = {
            folders: [],
            currentFolderIndex: 0,
            currentPage: 0,
            maxPages: 0,
            rectangles: [],
            drawing: false,
            startX: 0,
            startY: 0,
            currentRect: null
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let currentImage = null;

        // åˆå§‹åŒ–
        async function init() {
            // åˆå§‹åŒ–ä¿å­˜çš„æ ‡æ³¨å¯¹è±¡
            state.savedAnnotations = {};

            await loadFolders();
            if (state.folders.length > 0) {
                await loadCurrentImage();
                updateInfo();
            }
            setupCanvasEvents();
        }

        // ä»åç«¯åŠ è½½æ–‡ä»¶å¤¹åˆ—è¡¨
        async function loadFolders() {
            try {
                const response = await fetch(`${API_BASE}/folders`);
                const data = await response.json();

                if (data.success) {
                    state.folders = data.folders;
                    console.log('Loaded folders:', state.folders);
                } else {
                    showStatus('åŠ è½½æ–‡ä»¶å¤¹å¤±è´¥: ' + data.error, true);
                }
            } catch (error) {
                showStatus('è¿æ¥æœåŠ¡å™¨å¤±è´¥ï¼Œè¯·ç¡®ä¿åç«¯å·²å¯åŠ¨', true);
                console.error('Error loading folders:', error);
            }
        }

        // ä»åç«¯åŠ è½½å½“å‰å›¾ç‰‡
        async function loadCurrentImage() {
            if (state.folders.length === 0) return;

            try {
                const folder = state.folders[state.currentFolderIndex].name;

                // å…ˆåŠ è½½å›¾ç‰‡
                const response = await fetch(`${API_BASE}/image/${folder}/${state.currentPage}`);
                const data = await response.json();

                if (data.success) {
                    state.currentFilename = data.filename;

                    const img = new Image();
                    img.onload = async function() {
                        currentImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;

                        // å›¾ç‰‡åŠ è½½å®Œæˆåå†åŠ è½½æ ‡æ³¨
                        await loadSavedAnnotations(folder, state.currentPage);
                        redrawCanvas();
                    };
                    img.src = data.image;
                } else {
                    showStatus('åŠ è½½å›¾ç‰‡å¤±è´¥: ' + data.error, true);
                }
            } catch (error) {
                showStatus('åŠ è½½å›¾ç‰‡æ—¶å‡ºé”™', true);
                console.error('Error loading image:', error);
            }
        }

        // åŠ è½½å·²ä¿å­˜çš„æ ‡æ³¨
        async function loadSavedAnnotations(folder, page) {
            // åˆå§‹åŒ–æ–‡ä»¶å¤¹ç¼“å­˜
            if (!state.savedAnnotations[folder]) {
                state.savedAnnotations[folder] = {};
            }

            try {
                const response = await fetch(`${API_BASE}/annotations/${folder}/${page}`);
                const data = await response.json();

                if (data.success && data.rectangles) {
                    state.rectangles = data.rectangles;
                    // ç¼“å­˜åˆ°æœ¬åœ°
                    state.savedAnnotations[folder][page] = data.rectangles;
                } else {
                    // æ£€æŸ¥æœ¬åœ°ç¼“å­˜
                    if (state.savedAnnotations[folder][page]) {
                        state.rectangles = [...state.savedAnnotations[folder][page]];
                    } else {
                        state.rectangles = [];
                    }
                }

                updateRectangleList();
                updateInfo();
            } catch (error) {
                // å¦‚æœåŠ è½½å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æœ¬åœ°ç¼“å­˜
                if (state.savedAnnotations[folder][page]) {
                    state.rectangles = [...state.savedAnnotations[folder][page]];
                } else {
                    state.rectangles = [];
                }
                updateRectangleList();
                updateInfo();
                console.log('No saved annotations found for this page');
            }
        }

        // è®¾ç½®ç”»å¸ƒäº‹ä»¶
        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function isPointInRect(px, py, rect) {
            return px >= rect.x1 && px <= rect.x2 && py >= rect.y1 && py <= rect.y2;
        }

        function getResizeHandle(px, py, rect) {
            const threshold = 10;
            const onLeft = Math.abs(px - rect.x1) < threshold;
            const onRight = Math.abs(px - rect.x2) < threshold;
            const onTop = Math.abs(py - rect.y1) < threshold;
            const onBottom = Math.abs(py - rect.y2) < threshold;

            if (onTop && onLeft) return 'tl';
            if (onTop && onRight) return 'tr';
            if (onBottom && onLeft) return 'bl';
            if (onBottom && onRight) return 'br';
            if (onTop) return 'top';
            if (onBottom) return 'bottom';
            if (onLeft) return 'left';
            if (onRight) return 'right';
            return null;
        }

        function findRectAtPoint(px, py) {
            for (let i = state.rectangles.length - 1; i >= 0; i--) {
                if (isPointInRect(px, py, state.rectangles[i])) {
                    return i;
                }
            }
            return -1;
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);

            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†çŸ©å½¢
            const rectIndex = findRectAtPoint(pos.x, pos.y);

            if (rectIndex !== -1) {
                state.selectedRectIndex = rectIndex;
                const rect = state.rectangles[rectIndex];

                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è°ƒæ•´å¤§å°çš„æ§åˆ¶ç‚¹
                const handle = getResizeHandle(pos.x, pos.y, rect);

                if (handle) {
                    // å¼€å§‹è°ƒæ•´å¤§å°
                    state.resizing = true;
                    state.resizeHandle = handle;
                    state.startX = pos.x;
                    state.startY = pos.y;
                } else if (e.shiftKey) {
                    // æŒ‰ä½Shiftåˆ é™¤çŸ©å½¢
                    state.rectangles.splice(rectIndex, 1);
                    state.selectedRectIndex = -1;
                    updateRectangleList();
                    updateInfo();
                    redrawCanvas();
                    return;
                } else {
                    // å¼€å§‹æ‹–åŠ¨
                    state.dragging = true;
                    state.dragOffset = {
                        x: pos.x - rect.x1,
                        y: pos.y - rect.y1
                    };
                }
                redrawCanvas();
            } else {
                // å¼€å§‹ç»˜åˆ¶æ–°çŸ©å½¢
                state.drawing = true;
                state.startX = pos.x;
                state.startY = pos.y;
                state.selectedRectIndex = -1;
            }
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e);

            if (state.drawing) {
                // ç»˜åˆ¶æ–°çŸ©å½¢
                state.currentRect = {
                    x: Math.min(state.startX, pos.x),
                    y: Math.min(state.startY, pos.y),
                    width: Math.abs(pos.x - state.startX),
                    height: Math.abs(pos.y - state.startY)
                };
                redrawCanvas();
            } else if (state.dragging && state.selectedRectIndex !== -1) {
                // æ‹–åŠ¨çŸ©å½¢
                const rect = state.rectangles[state.selectedRectIndex];
                const width = rect.x2 - rect.x1;
                const height = rect.y2 - rect.y1;

                rect.x1 = pos.x - state.dragOffset.x;
                rect.y1 = pos.y - state.dragOffset.y;
                rect.x2 = rect.x1 + width;
                rect.y2 = rect.y1 + height;

                updateRectangleList();
                redrawCanvas();
            } else if (state.resizing && state.selectedRectIndex !== -1) {
                // è°ƒæ•´çŸ©å½¢å¤§å°
                const rect = state.rectangles[state.selectedRectIndex];
                const dx = pos.x - state.startX;
                const dy = pos.y - state.startY;

                switch (state.resizeHandle) {
                    case 'tl':
                        rect.x1 += dx;
                        rect.y1 += dy;
                        break;
                    case 'tr':
                        rect.x2 += dx;
                        rect.y1 += dy;
                        break;
                    case 'bl':
                        rect.x1 += dx;
                        rect.y2 += dy;
                        break;
                    case 'br':
                        rect.x2 += dx;
                        rect.y2 += dy;
                        break;
                    case 'top':
                        rect.y1 += dy;
                        break;
                    case 'bottom':
                        rect.y2 += dy;
                        break;
                    case 'left':
                        rect.x1 += dx;
                        break;
                    case 'right':
                        rect.x2 += dx;
                        break;
                }

                // ç¡®ä¿åæ ‡é¡ºåºæ­£ç¡®
                if (rect.x1 > rect.x2) [rect.x1, rect.x2] = [rect.x2, rect.x1];
                if (rect.y1 > rect.y2) [rect.y1, rect.y2] = [rect.y2, rect.y1];

                state.startX = pos.x;
                state.startY = pos.y;

                updateRectangleList();
                redrawCanvas();
            } else {
                // æ›´æ–°é¼ æ ‡æ‚¬åœçŠ¶æ€
                const rectIndex = findRectAtPoint(pos.x, pos.y);
                const oldHovered = state.hoveredRectIndex;
                state.hoveredRectIndex = rectIndex;

                // æ›´æ–°å…‰æ ‡æ ·å¼
                if (rectIndex !== -1) {
                    const rect = state.rectangles[rectIndex];
                    const handle = getResizeHandle(pos.x, pos.y, rect);

                    if (handle) {
                        const cursors = {
                            'tl': 'nw-resize', 'tr': 'ne-resize',
                            'bl': 'sw-resize', 'br': 'se-resize',
                            'top': 'n-resize', 'bottom': 's-resize',
                            'left': 'w-resize', 'right': 'e-resize'
                        };
                        canvas.style.cursor = cursors[handle];
                    } else {
                        canvas.style.cursor = 'move';
                    }
                } else {
                    canvas.style.cursor = 'crosshair';
                }

                if (oldHovered !== state.hoveredRectIndex) {
                    redrawCanvas();
                }
            }
        }

        function handleMouseUp(e) {
            if (state.drawing) {
                state.drawing = false;

                if (state.currentRect && state.currentRect.width > 5 && state.currentRect.height > 5) {
                    const rect = {
                        x1: Math.round(state.currentRect.x),
                        y1: Math.round(state.currentRect.y),
                        x2: Math.round(state.currentRect.x + state.currentRect.width),
                        y2: Math.round(state.currentRect.y + state.currentRect.height)
                    };
                    state.rectangles.push(rect);
                    updateRectangleList();
                    updateInfo();
                }

                state.currentRect = null;
            }

            state.dragging = false;
            state.resizing = false;
            state.resizeHandle = null;
            redrawCanvas();
        }

        // é‡ç»˜ç”»å¸ƒ
        function redrawCanvas() {
            if (!currentImage) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0);

            // ç»˜åˆ¶å·²ä¿å­˜çš„çŸ©å½¢
            state.rectangles.forEach((rect, index) => {
                const width = rect.x2 - rect.x1;
                const height = rect.y2 - rect.y1;

                // åˆ¤æ–­æ˜¯å¦è¢«é€‰ä¸­æˆ–æ‚¬åœ
                const isSelected = index === state.selectedRectIndex;
                const isHovered = index === state.hoveredRectIndex;

                // è®¾ç½®æ ·å¼
                if (isSelected) {
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(0, 0, 255, 0.15)';
                } else if (isHovered) {
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.1)';
                } else {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                }

                ctx.fillRect(rect.x1, rect.y1, width, height);
                ctx.strokeRect(rect.x1, rect.y1, width, height);

                // ç»˜åˆ¶æ ‡ç­¾
                ctx.fillStyle = isSelected ? 'blue' : 'red';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`åŒºåŸŸ ${index + 1}`, rect.x1 + 5, rect.y1 + 20);

                // å¦‚æœè¢«é€‰ä¸­ï¼Œç»˜åˆ¶è°ƒæ•´å¤§å°çš„æ§åˆ¶ç‚¹
                if (isSelected) {
                    drawResizeHandles(rect);
                }
            });

            // ç»˜åˆ¶æ­£åœ¨ç»˜åˆ¶çš„çŸ©å½¢
            if (state.currentRect) {
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(state.currentRect.x, state.currentRect.y,
                              state.currentRect.width, state.currentRect.height);
                ctx.setLineDash([]);
            }
        }

        function drawResizeHandles(rect) {
            const handleSize = 8;
            const handles = [
                { x: rect.x1, y: rect.y1 }, // å·¦ä¸Š
                { x: rect.x2, y: rect.y1 }, // å³ä¸Š
                { x: rect.x1, y: rect.y2 }, // å·¦ä¸‹
                { x: rect.x2, y: rect.y2 }, // å³ä¸‹
                { x: (rect.x1 + rect.x2) / 2, y: rect.y1 }, // ä¸Šä¸­
                { x: (rect.x1 + rect.x2) / 2, y: rect.y2 }, // ä¸‹ä¸­
                { x: rect.x1, y: (rect.y1 + rect.y2) / 2 }, // å·¦ä¸­
                { x: rect.x2, y: (rect.y1 + rect.y2) / 2 }  // å³ä¸­
            ];

            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;

            handles.forEach(handle => {
                ctx.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
                ctx.strokeRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
            });
        }

        // æ›´æ–°çŸ©å½¢åˆ—è¡¨
        function updateRectangleList() {
            const list = document.getElementById('rectangleList');
            list.innerHTML = '';

            if (state.rectangles.length === 0) {
                list.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">æš‚æ— æ ‡æ³¨åŒºåŸŸ</div>';
                return;
            }

            state.rectangles.forEach((rect, index) => {
                const item = document.createElement('div');
                item.className = 'rectangle-item';
                item.innerHTML = `
                    <div>
                        <strong>åŒºåŸŸ ${index + 1}</strong>
                        <div class="coords">[${rect.x1}, ${rect.y1}, ${rect.x2}, ${rect.y2}]</div>
                    </div>
                    <button class="delete-btn" onclick="deleteRectangle(${index})">åˆ é™¤</button>
                `;
                list.appendChild(item);
            });
        }

        // åˆ é™¤çŸ©å½¢
        function deleteRectangle(index) {
            state.rectangles.splice(index, 1);
            updateRectangleList();
            updateInfo();
            redrawCanvas();
        }

        // æ¸…ç©ºæ‰€æœ‰çŸ©å½¢
        function clearRectangles() {
            if (state.rectangles.length === 0) return;
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ ‡æ³¨åŒºåŸŸå—ï¼Ÿ')) return;

            state.rectangles = [];
            updateRectangleList();
            updateInfo();
            redrawCanvas();
            showStatus('å·²æ¸…ç©ºæ‰€æœ‰æ ‡æ³¨åŒºåŸŸ', false);
        }

        // å¯¼èˆªåŠŸèƒ½
        async function nextFolder() {
            if (state.currentFolderIndex < state.folders.length - 1) {
                state.currentFolderIndex++;
                state.currentPage = 0;
                state.selectedRectIndex = -1;
                state.hoveredRectIndex = -1;
                await loadCurrentImage();
                updateInfo();
            }
        }

        async function prevFolder() {
            if (state.currentFolderIndex > 0) {
                state.currentFolderIndex--;
                state.currentPage = 0;
                state.selectedRectIndex = -1;
                state.hoveredRectIndex = -1;
                await loadCurrentImage();
                updateInfo();
            }
        }

        async function nextPage() {
            const folder = state.folders[state.currentFolderIndex];
            // å°è¯•åŠ è½½ä¸‹ä¸€é¡µ
            const oldPage = state.currentPage;
            state.currentPage++;

            // ä¸´æ—¶åŠ è½½çœ‹æ˜¯å¦å­˜åœ¨
            const response = await fetch(`${API_BASE}/image/${folder.name}/${state.currentPage}`);
            const data = await response.json();

            if (data.success) {
                state.selectedRectIndex = -1;
                state.hoveredRectIndex = -1;
                await loadCurrentImage();
                updateInfo();
            } else {
                // æ¢å¤åŸæ¥çš„é¡µç 
                state.currentPage = oldPage;
                showStatus('å·²ç»æ˜¯æœ€åä¸€é¡µ', true);
            }
        }

        async function prevPage() {
            if (state.currentPage > 0) {
                state.currentPage--;
                state.selectedRectIndex = -1;
                state.hoveredRectIndex = -1;
                await loadCurrentImage();
                updateInfo();
            }
        }

        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        function updateInfo() {
            if (state.folders.length === 0) {
                document.getElementById('folderInfo').textContent = 'æ— å¯ç”¨æ–‡ä»¶å¤¹';
                document.getElementById('pageInfo').textContent = '-';
                document.getElementById('rectCount').textContent = '0';
                return;
            }

            const folder = state.folders[state.currentFolderIndex];
            document.getElementById('folderInfo').textContent =
                `${folder.name} (${state.currentFolderIndex + 1}/${state.folders.length})`;
            document.getElementById('pageInfo').textContent =
                state.currentFilename || `ç¬¬ ${state.currentPage + 1} å¼ `;
            document.getElementById('rectCount').textContent = state.rectangles.length;
        }

        // ä¿å­˜æ ‡æ³¨
        async function saveAnnotations() {
            if (state.rectangles.length === 0) {
                showStatus('æ²¡æœ‰å¯ä¿å­˜çš„æ ‡æ³¨åŒºåŸŸ', true);
                return;
            }

            const saveBtn = document.getElementById('saveBtn');
            saveBtn.disabled = true;
            saveBtn.textContent = 'ä¿å­˜ä¸­...';

            try {
                const folder = state.folders[state.currentFolderIndex].name;
                const response = await fetch(`${API_BASE}/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        folder: folder,
                        page: state.currentPage,
                        filename: state.currentFilename,
                        rectangles: state.rectangles
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // ç¼“å­˜å·²ä¿å­˜çš„æ ‡æ³¨
                    if (!state.savedAnnotations[folder]) {
                        state.savedAnnotations[folder] = {};
                    }
                    state.savedAnnotations[folder][state.currentPage] = [...state.rectangles];

                    let message = `âœ… å·²ä¿å­˜ ${state.rectangles.length} ä¸ªåŒºåŸŸåˆ° ${data.save_path}`;
                    if (data.marked_image) {
                        const filenameBase = state.currentFilename.replace('.png', '');
                        message += `\nğŸ“¸ å·²ç”Ÿæˆæ ‡æ³¨å›¾ç‰‡: ${filenameBase}_marked.png`;
                    }
                    showStatus(message, false);
                } else {
                    showStatus('ä¿å­˜å¤±è´¥: ' + data.error, true);
                }
            } catch (error) {
                showStatus('ä¿å­˜æ—¶å‡ºé”™: ' + error.message, true);
                console.error('Error saving:', error);
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'ğŸ’¾ ä¿å­˜æ‰€æœ‰åŒºåŸŸ';
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, isError) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status show' + (isError ? ' error' : '');

            setTimeout(() => {
                status.classList.remove('show');
            }, 3000);
        }

        // åˆå§‹åŒ–åº”ç”¨
        init();
    </script>
</body>
</html>